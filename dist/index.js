!function(e,s){"object"==typeof exports&&"undefined"!=typeof module?s(exports,require("gulp"),require("gulp-nodemon"),require("fs"),require("browser-sync"),require("gulp-sass"),require("node-sass"),require("autoprefixer"),require("gulp-postcss"),require("gulp-typescript"),require("rollup"),require("@rollup/plugin-node-resolve"),require("@rollup/plugin-commonjs"),require("@rollup/plugin-typescript"),require("@rollup/plugin-babel"),require("@rollup/plugin-terser"),require("@rollup/plugin-replace"),require("rollup-plugin-visualizer"),require("util"),require("gulp-replace"),require("gulp-git"),require("path"),require("url")):"function"==typeof define&&define.amd?define(["exports","gulp","gulp-nodemon","fs","browser-sync","gulp-sass","node-sass","autoprefixer","gulp-postcss","gulp-typescript","rollup","@rollup/plugin-node-resolve","@rollup/plugin-commonjs","@rollup/plugin-typescript","@rollup/plugin-babel","@rollup/plugin-terser","@rollup/plugin-replace","rollup-plugin-visualizer","util","gulp-replace","gulp-git","path","url"],s):s((e="undefined"!=typeof globalThis?globalThis:e||self).main={},e.gulp,e.nodemon,e.fs,e.bs,e.gulpSass,e.nodeSass,e.autoprefixer,e.postcss,e.ts,e.rollup,e.resolve,e.commonjs,e.typescript,e.babel,e.terser,e.rollupReplace,e.rollupPluginVisualizer,e.util,e.replace,e.git,e.path,e.url)}(this,(function(e,s,r,t,n,i,o,l,c,p,u,a,d,f,g,m,j,y,v,b,h,x,w){"use strict";function S(e){var s=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var t=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(s,r,t.get?t:{enumerable:!0,get:function(){return e[r]}})}})),s.default=e,Object.freeze(s)}var k=S(u);let q="vendor",P="public";const $=(e,s)=>t.existsSync("./"+e)?[e,!1]:(console.log(`Changing configured directory from ${e} to ${s}.`),[s,!0]);[P]=$(P,"src");const O={pkg:"./package.json",app:"app",serverscript:"app",server:"server",dist:"dist",build:"build",src:P,ejs:{src:"./views/**"},vendor:{dir:q,src:q+"/vendor.ts",src2:[q+"/**/*.js",q+"/**/*.ts",q+"/**/*.jsx",q+"/**/*.tsx"],dest:"/js",flnm:"/vendor.js"},js:{src:P+"/js/index.ts",src2:[P+"/js/**/*.js",P+"/js/**/*.ts",P+"/jsx/**/*.jsx",P+"/jsx/**/*.tsx"],map:P+"/js/importmap.json",dest:"/js",flnm:"/main.js"},jsx:{src:P+"/jsx/**/*",dest:"/jsx"},css:{src:[P+"/style/styles.scss",P+"/style/**/*.css"],src2:P+"/style/**/*.{scss,css}",dest:"/style"},img:{src:[P+"/img/**/*","!"+P+"/img/Unused*/**/*"],dest:"/img"},fonts:{src:P+"/fonts/**/*",dest:"/fonts"},data:{src:P+"/data/**/*",dest:"/data"}};let F=!1;if([O.js.src,F]=$(O.js.src,P+"/index.ts"),F&&(console.log("Sending index.js to dist folder."),O.js.flnm="index.js"),!t.existsSync(P+"/style")){console.log("Sending styles to dist folder.");for(let e=0;e<O.css.src.length;e++)O.css.src[e]=O.css.src[e].replace("/style","");O.css.src2=O.css.src2.replace("/style",""),O.css.dest=O.css.dest.replace("/style","")}let E=O.css.src[0],T=O.css.src[0].replace("styles","style");[O.css.src[0]]=$(E,T);const _=/Circular dependency.*d3-interpolate/;let N={},A=[],R={},U=[];const I=/import (\* as )?(.*) from ['"](.*)['"];/g,z=/\/\/\s?import (\* as )?(.*) from ['"](.*)['"];/g;if(t.existsSync(O.vendor.src)){const e=t.readFileSync(O.vendor.src,"utf-8");let s=e.matchAll(I);for(const e of s)e[2]&&e[3]&&(N[e[3]]=e[2],A.push(e[3]));s=e.matchAll(z);for(const e of s)e[2]&&e[3]&&(R[e[3]]=e[2],U.push(e[3]))}else{const e=JSON.parse(t.readFileSync("./package.json","utf-8"));A=Object.keys(e.dependencies||{})}let C=null;t.existsSync(`./${O.src}/tsconfig.json`)?C=f({tsconfig:`./${O.src}/tsconfig.json`}):t.existsSync("./tsconfig.json")&&(C=f({tsconfig:"./tsconfig.json"}));const M={input:O.js.src,plugins:[j({'"production"':JSON.stringify("production")}),a({extensions:[".js",".jsx",".ts",".tsx"]}),C,d({include:/node_modules/}),g({extensions:[".js",".jsx",".ts",".tsx"],presets:["@babel/env","@babel/preset-react"],targets:{browsers:"defaults and supports es6-module"},babelHelpers:"bundled",exclude:"node_modules/**"})],onwarn:function(e){_.test(e.message)},external:A};let V=O.build+O.js.dest+O.js.flnm,L=O.dist+O.js.dest+O.js.flnm;-1==O.js.flnm.indexOf("/")&&(V=O.build+"/"+O.js.flnm,L=O.dist+"/"+O.js.flnm);const D={file:V,format:"umd",plugins:[],name:"main",globals:N},J={...D};J.file=L,J.plugins=[m()];let H=null;t.existsSync(`./${O.vendor.dir}/tsconfig.json`)&&(H=f({tsconfig:`./${O.vendor.dir}/tsconfig.json`}));const B={input:O.vendor.src,plugins:[j({'"production"':JSON.stringify("production")}),a({extensions:[".js",".jsx",".ts",".tsx"]}),H,d({include:/node_modules/}),g({extensions:[".js",".jsx",".ts",".tsx"],presets:["@babel/env","@babel/preset-react"],targets:{browsers:"defaults and supports es6-module"},babelHelpers:"bundled"})],onwarn:function(e){_.test(e.message)},external:U},G={file:O.build+O.vendor.dest+O.vendor.flnm,format:"umd",plugins:[],name:"vendor",globals:R},K={...G};K.file=O.dist+O.vendor.dest+O.vendor.flnm,K.plugins=[m()];const Y=v.promisify(h.tag),Q=v.promisify(h.status),W=v.promisify(h.push),X=/"?version"?:\s*"(.*?)"/g,Z=e=>{let s=[0,0,0];if(!e)return s;let r=e.replace("v","").split(".");return s[0]=parseInt(r[0]??"0"),s[1]=parseInt(r[1]??"0"),s[2]=parseInt(r[2]??"0"),s},ee=e=>{let s=[0,0,0];if(t.existsSync(e)){let r=t.readFileSync(e,"utf8").matchAll(X);s=[0,0,0];for(const e of r){s=Z(e[1]);break}if(!s)return[0,0,0];console.log(`Found ${e} Version ${s.join(".")}`)}return s},se=(e,s)=>{if(e.length!=s.length)throw"This function will only compare versions with the same specificity.";for(let r=0;r<e.length;r++){if(!e[r])return s;if(!s[r])return e;if(e[r]>s[r])return e;if(e[r]<s[r])return s}return e},re=(e,s)=>{if(e.length!=s.length)throw"This function will only compare versions with the same specificity.";for(let r=0;r<e.length;r++)if(e[r]!=s[r])return!1;return!0},te=[" M app/app.ts\n M package.json\n"," M app/app.ts\n"," M package.json\n"];function ne(){t.existsSync(O.build+O.vendor.dest)||t.mkdirSync(O.build+O.vendor.dest,{recursive:!0}),t.existsSync(O.build+O.js.dest)||t.mkdirSync(O.build+O.js.dest,{recursive:!0}),t.existsSync(O.dist+O.js.dest)||t.mkdirSync(O.dist+O.js.dest,{recursive:!0})}const ie=w.fileURLToPath("undefined"==typeof document&&"undefined"==typeof location?require("url").pathToFileURL(ie).href:"undefined"==typeof document?location.href:document.currentScript&&document.currentScript.src||new URL("index.js",document.baseURI).href),oe=x.dirname(ie);function le(){t.existsSync("./.github/workflows")||t.mkdirSync("./.github/workflows",{recursive:!0})}const ce=n.create(),pe=i(o);function ue(){return t.existsSync(O.vendor.src)?(ne(),k.rollup(B).then((e=>Promise.all([e.write(G),e.write(K)])))):new Promise((e=>e()))}function ae(){return ne(),k.rollup(M).then((e=>Promise.all([e.write(D),e.write(J)])))}function de(){return t.existsSync(O.css.src[0])?s.src(O.css.src).pipe(pe({includePaths:["node_modules"]}).on("error",pe.logError)).pipe(c([l()])).pipe(s.dest(O.build+O.css.dest)).pipe(pe({outputStyle:"compressed",includePaths:["node_modules"]})).pipe(s.dest(O.dist+O.css.dest)):new Promise((e=>e()))}function fe(){return Promise.all([s.src(O.img.src).pipe(s.dest(O.build+O.img.dest)).pipe(s.dest(O.dist+O.img.dest)),s.src(O.fonts.src).pipe(s.dest(O.build+O.fonts.dest)).pipe(s.dest(O.dist+O.fonts.dest)),s.src(O.data.src).pipe(s.dest(O.build+O.data.dest)).pipe(s.dest(O.dist+O.data.dest))])}function ge(e){ce.reload(),e&&e()}function me(){if(!t.existsSync(O.app))return new Promise((e=>e()));process.chdir(O.app);let e=p.createProject("./tsconfig.json");return e.src().pipe(e()).js.pipe(s.dest(e.config.compilerOptions.outDir))}function je(){return new Promise(((e,s)=>{t.existsSync(O.dist)&&t.rmSync(O.dist,{recursive:!0}),t.existsSync(O.build)&&t.rmSync(O.build,{recursive:!0}),t.existsSync(O.server)&&t.rmSync(O.server,{recursive:!0}),e()}))}const ye=s.parallel(ue,ae,de,fe),ve=s.series(ye,me),be=s.series(je,ye,s.parallel((function(){ce.init({open:!1,proxy:"http://localhost:4987/",port:3e3}),s.watch(O.js.src2,s.series(ae,ge)),s.watch(O.vendor.src,s.series(ue,ge)),s.watch(O.ejs.src,s.series(ge)),s.watch(O.css.src2,s.series(de,ge)),s.watch([O.fonts.src,O.data.src,...O.img.src],s.series(fe,ge))}),(function(){return r({exec:`npx ts-node --files --project ./${O.app}/tsconfig.json ${O.app}/${O.serverscript}.ts`,ext:"html,js,ejs,css,jsx,ts,tsx",watch:[O.app],env:{NODE_ENV:"development"},execMap:{ts:"ts-node"}}).on("restart",(function(){console.log("restarted")}))}))),he=s.series(je,(()=>{let e,r,n=(()=>{let e=t.readdirSync("./.git/refs/tags");e.sort((function(e,s){let r=Z(e),t=Z(s);return r&&t?r[0]>t[0]||r[1]>t[1]||r[2]>t[2]?-1:1:0}));let s=Z(e[0]);return console.log(`Found Tag Version ${s.join(".")}`),s})(),i=ee(`${O.app}/${O.serverscript}.ts`),o=ee(O.pkg),l=se(n,i);if(l=se(l,o),re(l,n)&&(l[2]=(l[2]??0)+1),(e=>{for(let s=0;s<e.length;s++)if(0!=e[s])return!1;return!0})(i)?e=!0:re(l,i)?(e=!0,console.log("App version already incremented")):re(l,o)&&(r=!0,console.log("Package version already incremented")),e&&r)return console.log("Version already incremented"),s.src(".");let c,p,u=l.join(".");if(e||(console.log(`Incrementing version in app.ts from v${i?.join(".")} to v${u}`),c=s.src("./app/app.ts").pipe(b(X,`version: "${u}"`)).pipe(s.dest("./app/"))),!r){console.log(`Incrementing version in package.json from v${o?.join(".")} to v${u}`);let e=/--version v[\d\-]* /g;p=s.src("./package.json").pipe(b(X,`"version": "${u}"`)).pipe(b(e,`--version v${l.join("-")} `)).pipe(s.dest("./"))}let a=[];if(c&&p?a=[c,p]:c?a=[c]:p&&(a=[p]),a.length>0)return Promise.all(a).then((()=>setTimeout((()=>{!function(){let e=t.readFileSync("./package.json"),r=JSON.parse(e.toString()).version;Q({args:"--porcelain"}).then((e=>{if(!te.includes(e))throw console.log(" -- Detected changes -- "),console.log(e),console.log(" --  -- "),new Error('Task addTag can only be run on a clean repository. Run "git status --porcelain" to see what blocked the task.');return new Promise((function(e,r){s.src(["./app/app.ts","./package.json"]).pipe(h.add()).pipe(h.commit("Update version")).on("end",e)}))})).then((()=>Y("v"+r,"New version"))).then((()=>W("origin","main"))).then((()=>W("origin","main",{args:" --tags"}))).catch((e=>{if(e)throw console.log(e),e}))}()}),3e3)));throw new Error("Function incrementVersion failed to define increment task.")}),ve),xe=s.series((()=>(console.log("Creating flow to create release from new tag."),le(),s.src(oe+"/bin/create_release.yml").pipe(s.dest("./.github/workflows"))))),we=s.series((()=>{console.log("Creating flow to create package from new release."),console.log("ONLY USE FOR PUBLIC REPOS"),le();let e;e=t.existsSync(O.pkg)?t.readFileSync(O.pkg,"utf8"):t.readFileSync("../package.json","utf8");let r=e.matchAll(/"?name"?:\s*"(.*?)"/g),n="";for(const e of r)e[1]&&(n=e[1]);let i=null;return x.resolve(oe+"/bin/devpack.sh")!=x.resolve("./bin/devpack.sh")&&(i=s.src(oe+"/bin/devpack.sh").pipe(s.dest("./bin"))),Promise.all([s.src(oe+"/bin/release_package.yml").pipe(s.dest("./.github/workflows")),s.src(oe+"/bin/scope_package.js").pipe(b(/\{\{PACKAGE\_NAME\}\}/g,n)).pipe(s.dest("./.github/workflows")),i])}));e.build=ve,e.clean=je,e.css=de,e.dev=be,e.frontbuild=ye,e.js=ae,e.makeprivateflows=xe,e.makepublicflows=we,e.release=he,e.serverbuild=me,e.statics=fe,e.vendorjs=ue,e.visualizejs=function(){ne();let e=M;return e.plugins.push(y.visualizer),k.rollup(e).then((e=>Promise.all([e.write(D),e.write(J)])))}}));
